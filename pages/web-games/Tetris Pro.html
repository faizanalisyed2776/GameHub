<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Tetris Pro</title>
    <style>
        /* ===== BASE STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        :root {
            --color-primary: #FF5555;
            --color-primary-dark: #CC4444;
            --color-secondary: #55FF55;
            --color-secondary-dark: #44CC44;
            --color-tertiary: #5555FF;
            --color-tertiary-dark: #4444CC;
            --color-accent: #FFFF55;
            --color-accent-dark: #CCCC44;
            --color-special: #FF55FF;
            --color-special-dark: #CC44CC;
            --color-text: #FFFFFF;
            --color-text-dark: #CCCCCC;
            --color-bg: #111122;
            --color-bg-light: #222244;
            --color-shadow: rgba(0, 0, 0, 0.7);
            --color-glow: rgba(125, 249, 255, 0.7);
            --grid-size: 30px;
            --grid-cols: 10;
            --grid-rows: 20;
        }
 /* Navbar Styles */
:root {

  --background: #ffffff;
  --surface: #f9f9f9;
  --text: #0f0f0f;
  --primary: #ff6f61; /* Orange */
  --secondary: #ff4a3d; /* Darker Orange */
  --hover: rgba(0, 0, 0, 0.1);
  --border: rgba(0, 0, 0, 0.2);
}
        .navbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 50px;
    backdrop-filter: blur(15px);
   
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    position: fixed;
    width: 100%;
    top: 0;
    z-index: 1000;
    transition: background 0.3s ease, box-shadow 0.3s ease;
  }
  
  Navbar Left
  .nav-left {
    display: flex;
    align-items: center;
    gap: 20px;
  }
  
  .logo {
    display: flex;
    align-items: center;
    font-size: 26px;
    font-weight: 700;
    color: var(--primary);
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: transform 0.3s ease;
  }
  
  .logo:hover {
    transform: scale(1.1);
  }
  
  .logo i {
    font-size: 32px;
    margin-right: 10px;
    color: var(--secondary);
    animation: pulse 1.5s infinite alternate;
  }
  
  /* Nav Links */
  .nav-links ul {
    display: flex;
    list-style: none;
    gap: 30px;
    margin: 0;
    padding: 0;
  }
  
  .nav-links a {
    text-decoration: none;
    color: var(--text);
    font-weight: 600;
    font-size: 16px;
    text-transform: uppercase;
    transition: color 0.3s ease, transform 0.2s ease;
    position: relative;
    padding: 5px 10px;
  }
  
  .nav-links a:hover {
    color: var(--primary);
    transform: translateY(-3px);
  }
  
  
  /* Navbar Right */
  .nav-right {
    display: flex;
    align-items: center;
    gap: 15px;
  }
  
  /* Theme Toggle */

  
  
  /* Join Button */
  .join-button {
    padding: 10px 20px;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: #fff;
    border: none;
    border-radius: 5px;
    font-size: 16px;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
  }
  
  .join-button:hover {
    background: var(--secondary);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(255, 111, 97, 0.5);
  }
  
  /* Responsive Navbar */
  @media (max-width: 768px) {
    .nav-links {
        position: absolute;
        top: 80px;
        left: 0;
        background: var(--surface);
        backdrop-filter: blur(10px);
        flex-direction: column;
        width: 100%;
        align-items: center;
        gap: 20px;
        padding: 20px 0;
        display: none;
    }
  
    .nav-links.active {
        display: flex;
    }
  
    .nav-links ul {
        flex-direction: column;
        gap: 20px;
    }
  
    .hamburger {
        display: block;
        font-size: 30px;
        color: var(--text);
        cursor: pointer;
        transition: transform 0.3s ease;
    }
  
    .hamburger:hover {
        transform: rotate(180deg);
    }
  }
        body {
            background-color: var(--color-bg);
            overflow: hidden;
            touch-action: none;
            font-family: 'Press Start 2P', cursive;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            overscroll-behavior: none;
            height: 100vh;
            width: 100vw;
        }

        @font-face {
            font-family: 'Press Start 2P';
            src: url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
            font-display: swap;
        }

        /* ===== GAME CONTAINER ===== */
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            perspective: 1000px;
            isolation: isolate;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="800" viewBox="0 0 400 800"><rect width="400" height="800" fill="%23111122"/><rect x="50" y="50" width="300" height="700" fill="%23222244" opacity="0.3"/><path d="M50 50 L350 50 L350 750 L50 750 Z" fill="none" stroke="%237DF9FF" stroke-width="2" opacity="0.5"/></svg>');
            background-size: cover;
        }

        /* ===== GAME BOARD ===== */
        #gameBoard {
            position: absolute;
            width: calc(var(--grid-cols) * var(--grid-size));
            height: calc(var(--grid-rows) * var(--grid-size));
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(34, 34, 68, 0.3);
            border: 2px solid var(--color-glow);
            box-shadow: 0 0 20px rgba(34, 34, 68, 0.7);
            display: grid;
            grid-template-columns: repeat(var(--grid-cols), 1fr);
            grid-template-rows: repeat(var(--grid-rows), 1fr);
            gap: 1px;
            z-index: 2;
        }

        .grid-cell {
            background-color: rgba(17, 17, 34, 0.5);
            border: 1px solid rgba(125, 249, 255, 0.1);
            transition: background-color 0.1s, box-shadow 0.1s;
        }

        /* ===== TETROMINO COLORS ===== */
        .cell-I { background-color: #00FFFF; box-shadow: inset 0 0 10px #00AAAA, 0 0 5px #00FFFF; }
        .cell-J { background-color: #0000FF; box-shadow: inset 0 0 10px #0000AA, 0 0 5px #0000FF; }
        .cell-L { background-color: #FFAA00; box-shadow: inset 0 0 10px #AA7700, 0 0 5px #FFAA00; }
        .cell-O { background-color: #FFFF00; box-shadow: inset 0 0 10px #AAAA00, 0 0 5px #FFFF00; }
        .cell-S { background-color: #00FF00; box-shadow: inset 0 0 10px #00AA00, 0 0 5px #00FF00; }
        .cell-T { background-color: #AA00FF; box-shadow: inset 0 0 10px #7700AA, 0 0 5px #AA00FF; }
        .cell-Z { background-color: #FF0000; box-shadow: inset 0 0 10px #AA0000, 0 0 5px #FF0000; }
        .cell-ghost { opacity: 0.3; }

        /* ===== GAME UI ===== */
        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--color-text);
            font-size: 14px;
            text-shadow: 2px 2px 0 var(--color-shadow), 0 0 10px var(--color-glow);
            z-index: 10;
        }

        #nextPieceContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            background-color: rgba(34, 34, 68, 0.5);
            border: 2px solid var(--color-glow);
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 1px;
            z-index: 10;
        }

        #holdPieceContainer {
            position: absolute;
            top: 160px;
            right: 20px;
            width: 120px;
            height: 120px;
            background-color: rgba(34, 34, 68, 0.5);
            border: 2px solid var(--color-glow);
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 1px;
            z-index: 10;
        }

        /* ===== GAME CONTROLS ===== */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: none;
            justify-content: center;
            gap: 10px;
            z-index: 10;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(34, 34, 68, 0.7);
            border: 2px solid var(--color-glow);
            border-radius: 50%;
            color: var(--color-text);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
        }

        /* ===== GAME OVER SCREEN ===== */
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            backdrop-filter: blur(5px);
        }

        #gameOverScreen h1 {
            font-size: 36px;
            color: var(--color-primary);
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 var(--color-shadow), 0 0 15px var(--color-primary);
            animation: pulse 1s infinite alternate;
        }

        .game-over-stat {
            font-size: 18px;
            color: var(--color-text);
            margin-bottom: 10px;
            text-shadow: 2px 2px 0 var(--color-shadow);
        }

        .menu-btn {
            background: linear-gradient(to bottom, var(--color-primary), var(--color-primary-dark));
            color: var(--color-text);
            border: none;
            padding: 12px 24px;
            font-family: 'Press Start 2P';
            font-size: 12px;
            cursor: pointer;
            border-radius: 5px;
            margin: 10px;
            box-shadow: 3px 3px 0 var(--color-shadow), 0 0 10px var(--color-primary);
            transition: all 0.2s;
        }

        .menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 4px 4px 0 var(--color-shadow), 0 0 15px var(--color-primary);
        }

        .menu-btn:active {
            transform: translateY(1px);
            box-shadow: 2px 2px 0 var(--color-shadow), 0 0 5px var(--color-primary);
        }

        /* ===== START SCREEN ===== */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, var(--color-bg), #000000);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
        }

        #startScreen h1 {
            font-size: 48px;
            color: var(--color-primary);
            margin-bottom: 20px;
            text-shadow: 4px 4px 0 var(--color-shadow), 0 0 20px var(--color-primary);
            animation: titleGlow 1.5s infinite alternate;
        }

        #startScreen p {
            font-size: 16px;
            color: var(--color-text);
            margin-bottom: 40px;
            text-shadow: 2px 2px 0 var(--color-shadow);
            text-align: center;
            line-height: 1.6;
        }

        #startBtn {
            background: linear-gradient(to bottom, var(--color-secondary), var(--color-secondary-dark));
            color: var(--color-text);
            border: none;
            padding: 16px 32px;
            font-family: 'Press Start 2P';
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            margin: 10px;
            box-shadow: 4px 4px 0 var(--color-shadow), 0 0 15px var(--color-secondary);
            transition: all 0.2s;
        }

        #startBtn:hover {
            transform: scale(1.05);
            box-shadow: 5px 5px 0 var(--color-shadow), 0 0 20px var(--color-secondary);
        }

        #startBtn:active {
            transform: scale(0.98);
        }

        /* ===== PARTICLE EFFECTS ===== */
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
            will-change: transform;
            backface-visibility: hidden;
        }

        /* ===== ANIMATIONS ===== */
        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        @keyframes titleGlow {
            0% { 
                text-shadow: 
                    4px 4px 0 var(--color-shadow),
                    0 0 20px var(--color-primary); 
            }
            100% { 
                text-shadow: 
                    4px 4px 0 var(--color-shadow),
                    0 0 30px var(--color-primary),
                    0 0 50px var(--color-glow); 
            }
        }

        @keyframes lineClear {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.2); }
        }

        @keyframes pieceLock {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* ===== RESPONSIVE ADJUSTMENTS ===== */
        @media (max-width: 768px) {
            :root {
                --grid-size: 25px;
            }

            #startScreen h1 {
                font-size: 32px;
            }

            #startScreen p {
                font-size: 14px;
                padding: 0 20px;
            }

            #mobileControls {
                display: flex;
            }
        }

        @media (max-height: 700px) {
            :root {
                --grid-size: 25px;
            }
        }

        /* ===== PERFORMANCE OPTIMIZATIONS ===== */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }
    </style>
</head>
<body>
    
<nav class="navbar">
    <div class="nav-left">
    <button class="hamburger" id="hamburger"><i class='bx bx-menu'></i></button>
       
      <div class="logo"><i class='bx bxs-game'></i> <span>GameHub</span></div>
    </div>
    <div class="nav-links" id="navLinks">
      <ul>
        <li><a href="/index.html"><i class='bx bx-home'></i> Home</a></li>
        <li><a href="/index.html#web-games"><i class='bx bx-joystick'></i> Games</a></li>
        <li><a href="/pages/about.html"><i class='bx bx-user'></i> About Us</a></li>
        <li><a href="/pages/"><i class='bx  bx-store-alt'  ></i>  Store</a></li>
        <li><a href="/pages/contact.html"><i class='bx bx-envelope'></i> Contact Us</a></li>
      </ul>
    </div>
  <a href="/pages/join.html"><button class="join-button">Join</button></a> 
     
    </div>
  </nav>  <div id="gameContainer">
        <!-- Game Board -->
        <div id="gameBoard"></div>
        
        <!-- Game UI -->
        <div id="gameUI">
            <div>SCORE: <span id="score">0</span></div>
            <div>LEVEL: <span id="level">1</span></div>
            <div>LINES: <span id="lines">0</span></div>
        </div>
        
        <!-- Next Piece Preview -->
        <div id="nextPieceContainer"></div>
        
        <!-- Hold Piece -->
        <div id="holdPieceContainer"></div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls">
            <div class="mobile-btn" id="moveLeft">←</div>
            <div class="mobile-btn" id="moveRight">→</div>
            <div class="mobile-btn" id="rotateBtn">↻</div>
            <div class="mobile-btn" id="hardDrop">↓</div>
            <div class="mobile-btn" id="holdBtn">HOLD</div>
        </div>
        
        <!-- Game Over Screen -->
        <div id="gameOverScreen">
            <h1>GAME OVER</h1>
            <div class="game-over-stat">FINAL SCORE: <span id="finalScore">0</span></div>
            <div class="game-over-stat">LEVEL REACHED: <span id="finalLevel">1</span></div>
            <div class="game-over-stat">LINES CLEARED: <span id="finalLines">0</span></div>
            <button class="menu-btn" id="restartBtn">PLAY AGAIN</button>
            <a href="/index.html"><button class="menu-btn" id="menuBtn">MAIN MENU</button></a>
        </div>
        
        <!-- Start Screen -->
        <div id="startScreen">
            <h1>NEON TETRIS PRO</h1>
            <p>ULTIMATE 8-BIT TETRIS EXPERIENCE<br>WITH MODERN EFFECTS AND GAMEPLAY</p>
            <button id="startBtn">START GAME</button>
        </div>
    </div>

    <script>
        // ===== GAME CONSTANTS =====
        const TETROMINOES = {
            I: {
                shape: [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                className: 'cell-I'
            },
            J: {
                shape: [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                className: 'cell-J'
            },
            L: {
                shape: [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                className: 'cell-L'
            },
            O: {
                shape: [
                    [1, 1],
                    [1, 1]
                ],
                className: 'cell-O'
            },
            S: {
                shape: [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ],
                className: 'cell-S'
            },
            T: {
                shape: [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                className: 'cell-T'
            },
            Z: {
                shape: [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ],
                className: 'cell-Z'
            }
        };

        const COLORS = {
            I: '#00FFFF',
            J: '#0000FF',
            L: '#FFAA00',
            O: '#FFFF00',
            S: '#00FF00',
            T: '#AA00FF',
            Z: '#FF0000'
        };

        const CONFIG = {
            gridCols: 10,
            gridRows: 20,
            levelSpeed: [
                800, 720, 630, 550, 470, 380, 300, 220, 130, 100,
                80, 80, 80, 70, 70, 70, 50, 50, 30, 30,
                20, 20, 20, 15, 15, 15, 10, 10, 5, 5
            ],
            linesPerLevel: 10,
            scoreForLines: [100, 300, 500, 800],
            ghostOpacity: 0.3,
            mobileThreshold: 30,
            dasDelay: 150, // Delayed Auto Shift
            arrDelay: 50,  // Auto Repeat Rate
            lockDelay: 500 // Piece lock delay
        };

        // ===== GAME STATE =====
        const state = {
            grid: [],
            currentPiece: null,
            nextPiece: null,
            heldPiece: null,
            canHold: true,
            position: { x: 0, y: 0 },
            score: 0,
            level: 1,
            lines: 0,
            gameOver: false,
            isPaused: false,
            isMobile: false,
            lastFrameTime: 0,
            dropInterval: 0,
            dropCounter: 0,
            lastDropTime: 0,
            keysPressed: {},
            touchStartX: 0,
            touchStartY: 0,
            dasCounter: 0,
            arrCounter: 0,
            lockCounter: 0,
            particles: [],
            highScore: localStorage.getItem('tetrisHighScore') || 0
        };

        // ===== DOM ELEMENTS =====
        const elements = {
            gameBoard: document.getElementById('gameBoard'),
            gameUI: document.getElementById('gameUI'),
            scoreDisplay: document.getElementById('score'),
            levelDisplay: document.getElementById('level'),
            linesDisplay: document.getElementById('lines'),
            nextPieceContainer: document.getElementById('nextPieceContainer'),
            holdPieceContainer: document.getElementById('holdPieceContainer'),
            mobileControls: document.getElementById('mobileControls'),
            gameOverScreen: document.getElementById('gameOverScreen'),
            finalScoreDisplay: document.getElementById('finalScore'),
            finalLevelDisplay: document.getElementById('finalLevel'),
            finalLinesDisplay: document.getElementById('finalLines'),
            startScreen: document.getElementById('startScreen'),
            startBtn: document.getElementById('startBtn'),
            restartBtn: document.getElementById('restartBtn'),
            menuBtn: document.getElementById('menuBtn'),
            moveLeftBtn: document.getElementById('moveLeft'),
            moveRightBtn: document.getElementById('moveRight'),
            rotateBtn: document.getElementById('rotateBtn'),
            hardDropBtn: document.getElementById('hardDrop'),
            holdBtn: document.getElementById('holdBtn')
        };

        // ===== INITIALIZATION =====
        function init() {
            checkMobile();
            setupEventListeners();
            createGrid();
            resetGame();
            gameLoop();
        }

        function checkMobile() {
            state.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (state.isMobile) {
                elements.mobileControls.style.display = 'flex';
            }
        }

        function createGrid() {
            // Clear existing grid
            elements.gameBoard.innerHTML = '';
            
            // Create grid cells
            for (let row = 0; row < CONFIG.gridRows; row++) {
                for (let col = 0; col < CONFIG.gridCols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    elements.gameBoard.appendChild(cell);
                }
            }
            
            // Initialize grid state
            state.grid = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(0));
        }

        function createNextPieceGrid() {
            elements.nextPieceContainer.innerHTML = '';
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    elements.nextPieceContainer.appendChild(cell);
                }
            }
        }

        function createHoldPieceGrid() {
            elements.holdPieceContainer.innerHTML = '';
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    elements.holdPieceContainer.appendChild(cell);
                }
            }
        }

        // ===== GAME LOGIC =====
        function resetGame() {
            // Reset game state
            state.grid = Array(CONFIG.gridRows).fill().map(() => Array(CONFIG.gridCols).fill(0));
            state.score = 0;
            state.level = 1;
            state.lines = 0;
            state.gameOver = false;
            state.canHold = true;
            state.heldPiece = null;
            
            // Update UI
            updateScore();
            updateLevel();
            updateLines();
            
            // Setup first pieces
            state.nextPiece = getRandomPiece();
            createNextPiece();
            
            // Calculate initial drop speed
            updateDropSpeed();
            
            // Clear any existing pieces from board
            clearBoard();
        }

        function getRandomPiece() {
            const tetrominoes = 'IJLOSTZ';
            const rand = tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
            return {
                type: rand,
                shape: TETROMINOES[rand].shape,
                className: TETROMINOES[rand].className
            };
        }

        function createNextPiece() {
            state.currentPiece = state.nextPiece;
            state.nextPiece = getRandomPiece();
            state.position = { x: Math.floor(CONFIG.gridCols / 2) - Math.floor(state.currentPiece.shape[0].length / 2), y: 0 };
            state.canHold = true;
            
            // Update next piece display
            updateNextPieceDisplay();
            
            // Check if game over
            if (checkCollision()) {
                gameOver();
            }
        }

        function updateNextPieceDisplay() {
            const cells = elements.nextPieceContainer.querySelectorAll('.grid-cell');
            cells.forEach(cell => cell.className = 'grid-cell');
            
            const piece = state.nextPiece;
            const size = piece.shape.length;
            const offset = Math.floor((4 - size) / 2);
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (piece.shape[y][x]) {
                        const index = (y + offset) * 4 + (x + offset);
                        cells[index].classList.add(piece.className);
                    }
                }
            }
        }

        function updateHoldPieceDisplay() {
            const cells = elements.holdPieceContainer.querySelectorAll('.grid-cell');
            cells.forEach(cell => cell.className = 'grid-cell');
            
            if (!state.heldPiece) return;
            
            const piece = state.heldPiece;
            const size = piece.shape.length;
            const offset = Math.floor((4 - size) / 2);
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (piece.shape[y][x]) {
                        const index = (y + offset) * 4 + (x + offset);
                        cells[index].classList.add(piece.className);
                    }
                }
            }
        }

        function rotatePiece() {
            const originalShape = state.currentPiece.shape;
            const originalPosition = { ...state.position };
            
            // Transpose matrix
            const newShape = state.currentPiece.shape[0].map((_, index) => 
                state.currentPiece.shape.map(row => row[index])
            );
            
            // Reverse each row to get a 90 degree rotation
            state.currentPiece.shape = newShape.map(row => [...row].reverse());
            
            // Wall kick - if rotation causes collision, try adjusting position
            if (checkCollision()) {
                // Try moving left
                state.position.x -= 1;
                if (checkCollision()) {
                    // Try moving right
                    state.position.x += 2;
                    if (checkCollision()) {
                        // Try moving further right for I piece
                        if (state.currentPiece.type === 'I') {
                            state.position.x += 1;
                            if (checkCollision()) {
                                // Revert all changes
                                state.position.x -= 3;
                                state.currentPiece.shape = originalShape;
                            }
                        } else {
                            // Revert all changes
                            state.position.x -= 2;
                            state.currentPiece.shape = originalShape;
                        }
                    }
                }
            }
            
            // Play rotation sound
            playSound('rotate');
        }

        function movePiece(direction) {
            switch (direction) {
                case 'left':
                    state.position.x -= 1;
                    if (checkCollision()) {
                        state.position.x += 1;
                    } else {
                        resetLockDelay();
                        playSound('move');
                    }
                    break;
                    
                case 'right':
                    state.position.x += 1;
                    if (checkCollision()) {
                        state.position.x -= 1;
                    } else {
                        resetLockDelay();
                        playSound('move');
                    }
                    break;
                    
                case 'down':
                    state.position.y += 1;
                    if (checkCollision()) {
                        state.position.y -= 1;
                        lockPiece();
                    } else {
                        resetLockDelay();
                    }
                    break;
                    
                case 'up': // Hard drop
                    while (!checkCollision()) {
                        state.position.y += 1;
                    }
                    state.position.y -= 1;
                    lockPiece();
                    playSound('hardDrop');
                    break;
            }
            
            updateBoard();
        }

        function resetLockDelay() {
            state.lockCounter = 0;
        }

        function checkCollision() {
            const piece = state.currentPiece;
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x] !== 0) {
                        const newX = state.position.x + x;
                        const newY = state.position.y + y;
                        
                        // Check boundaries
                        if (newX < 0 || newX >= CONFIG.gridCols || newY >= CONFIG.gridRows) {
                            return true;
                        }
                        
                        // Check if already occupied in grid
                        if (newY >= 0 && state.grid[newY][newX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function lockPiece() {
            const piece = state.currentPiece;
            
            // Add piece to grid
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        const gridY = state.position.y + y;
                        const gridX = state.position.x + x;
                        
                        if (gridY >= 0) { // Only lock if within visible grid
                            state.grid[gridY][gridX] = piece.className;
                            
                            // Add lock animation to cell
                            const cell = getCellElement(gridY, gridX);
                            cell.style.animation = 'pieceLock 0.2s';
                            setTimeout(() => {
                                cell.style.animation = '';
                            }, 200);
                        }
                    }
                }
            }
            
            // Check for completed lines
            checkLines();
            
            // Create new piece
            createNextPiece();
            
            // Play lock sound
            playSound('lock');
        }

        function checkLines() {
            let linesCleared = 0;
            
            // Check each row from bottom up
            for (let y = CONFIG.gridRows - 1; y >= 0; y--) {
                // Check if line is complete
                if (state.grid[y].every(cell => cell !== 0)) {
                    // Remove line
                    state.grid.splice(y, 1);
                    // Add new empty line at top
                    state.grid.unshift(Array(CONFIG.gridCols).fill(0));
                    linesCleared++;
                    y++; // Check same row again after shift
                    
                    // Add line clear effect
                    addLineClearEffect(y);
                }
            }
            
            if (linesCleared > 0) {
                // Update score
                state.lines += linesCleared;
                state.score += CONFIG.scoreForLines[Math.min(linesCleared - 1, 3)] * state.level;
                
                // Check level up
                const newLevel = Math.floor(state.lines / CONFIG.linesPerLevel) + 1;
                if (newLevel > state.level) {
                    state.level = newLevel;
                    updateDropSpeed();
                    playSound('levelUp');
                } else {
                    playSound('lineClear');
                }
                
                updateScore();
                updateLevel();
                updateLines();
            }
        }

        function addLineClearEffect(y) {
            // Create particles for cleared line
            for (let x = 0; x < CONFIG.gridCols; x++) {
                const cell = getCellElement(y, x);
                cell.style.animation = 'lineClear 0.3s forwards';
                
                // Create explosion particles
                createParticle(
                    cell.offsetLeft + cell.offsetWidth / 2,
                    cell.offsetTop + cell.offsetHeight / 2,
                    Math.random() * 4 + 3,
                    COLORS[state.currentPiece.type],
                    Math.random() * 360,
                    Math.random() * 50 + 50
                );
            }
        }

        function holdPiece() {
            if (!state.canHold) return;
            
            playSound('hold');
            
            if (state.heldPiece) {
                // Swap current piece with held piece
                const temp = state.currentPiece;
                state.currentPiece = state.heldPiece;
                state.heldPiece = temp;
            } else {
                // Just hold the current piece and get a new one
                state.heldPiece = state.currentPiece;
                createNextPiece();
            }
            
            // Reset position
            state.position = { x: Math.floor(CONFIG.gridCols / 2) - Math.floor(state.currentPiece.shape[0].length / 2), y: 0 };
            state.canHold = false;
            
            // Update hold display
            updateHoldPieceDisplay();
            
            // Reset lock delay
            resetLockDelay();
        }

        function updateDropSpeed() {
            const levelIndex = Math.min(state.level - 1, CONFIG.levelSpeed.length - 1);
            state.dropInterval = CONFIG.levelSpeed[levelIndex];
        }

        function updateScore() {
            elements.scoreDisplay.textContent = state.score;
        }

        function updateLevel() {
            elements.levelDisplay.textContent = state.level;
        }

        function updateLines() {
            elements.linesDisplay.textContent = state.lines;
        }

        function clearBoard() {
            const cells = elements.gameBoard.querySelectorAll('.grid-cell');
            cells.forEach(cell => {
                cell.className = 'grid-cell';
                cell.style.animation = '';
            });
        }

        function updateBoard() {
            // Clear the board
            clearBoard();
            
            // Draw locked pieces
            for (let y = 0; y < CONFIG.gridRows; y++) {
                for (let x = 0; x < CONFIG.gridCols; x++) {
                    if (state.grid[y][x]) {
                        const cell = getCellElement(y, x);
                        cell.className = 'grid-cell ' + state.grid[y][x];
                    }
                }
            }
            
            // Draw current piece
            if (state.currentPiece) {
                const piece = state.currentPiece;
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const gridY = state.position.y + y;
                            const gridX = state.position.x + x;
                            
                            if (gridY >= 0) { // Only draw if within visible grid
                                const cell = getCellElement(gridY, gridX);
                                cell.className = 'grid-cell ' + piece.className;
                            }
                        }
                    }
                }
                
                // Draw ghost piece
                drawGhostPiece();
            }
        }

        function drawGhostPiece() {
            const piece = state.currentPiece;
            const ghostY = getGhostPieceY();
            
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        const gridY = ghostY + y;
                        const gridX = state.position.x + x;
                        
                        if (gridY >= 0) { // Only draw if within visible grid
                            const cell = getCellElement(gridY, gridX);
                            cell.classList.add(piece.className, 'cell-ghost');
                        }
                    }
                }
            }
        }

        function getGhostPieceY() {
            let ghostY = state.position.y;
            while (!checkCollisionAt(ghostY + 1, state.position.x)) {
                ghostY++;
            }
            return ghostY;
        }

        function checkCollisionAt(y, x) {
            const originalY = state.position.y;
            const originalX = state.position.x;
            state.position.y = y;
            state.position.x = x;
            
            const collided = checkCollision();
            
            state.position.y = originalY;
            state.position.x = originalX;
            
            return collided;
        }

        function getCellElement(row, col) {
            return elements.gameBoard.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        }

        // ===== GAME FLOW =====
        function gameOver() {
            state.gameOver = true;
            
            // Update high score
            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('tetrisHighScore', state.highScore);
            }
            
            // Update game over screen
            elements.finalScoreDisplay.textContent = state.score;
            elements.finalLevelDisplay.textContent = state.level;
            elements.finalLinesDisplay.textContent = state.lines;
            
            // Show game over screen
            elements.gameOverScreen.style.display = 'flex';
            
            // Play game over sound
            playSound('gameOver');
        }

        function startGame() {
            elements.startScreen.style.display = 'none';
            resetGame();
        }

        function returnToMenu() {
            elements.gameOverScreen.style.display = 'none';
            elements.startScreen.style.display = 'flex';
        }

        // ===== INPUT HANDLING =====
        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Touch controls
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
            
            // Button controls
            elements.startBtn.addEventListener('click', startGame);
            elements.restartBtn.addEventListener('click', resetGame);
            elements.menuBtn.addEventListener('click', returnToMenu);
            
            // Mobile controls
            if (state.isMobile) {
                elements.moveLeftBtn.addEventListener('touchstart', () => movePiece('left'));
                elements.moveRightBtn.addEventListener('touchstart', () => movePiece('right'));
                elements.rotateBtn.addEventListener('touchstart', () => rotatePiece());
                elements.hardDropBtn.addEventListener('touchstart', () => movePiece('up'));
                elements.holdBtn.addEventListener('touchstart', () => holdPiece());
            }
            
            // Window events
            window.addEventListener('blur', () => { if (!state.gameOver) state.isPaused = true; });
            window.addEventListener('focus', () => { state.isPaused = false; });
        }

        function handleKeyDown(e) {
            if (state.gameOver || state.isPaused) return;
            
            state.keysPressed[e.key] = true;
            
            switch (e.key) {
                case 'ArrowLeft':
                    movePiece('left');
                    state.dasCounter = CONFIG.dasDelay;
                    break;
                    
                case 'ArrowRight':
                    movePiece('right');
                    state.dasCounter = CONFIG.dasDelay;
                    break;
                    
                case 'ArrowDown':
                    movePiece('down');
                    break;
                    
                case 'ArrowUp':
                    rotatePiece();
                    break;
                    
                case ' ':
                    movePiece('up');
                    break;
                    
                case 'c':
                case 'C':
                    holdPiece();
                    break;
                    
                case 'p':
                case 'P':
                    state.isPaused = !state.isPaused;
                    break;
            }
            
            // Prevent default for space bar
            if (e.key === ' ') {
                e.preventDefault();
            }
        }

        function handleKeyUp(e) {
            state.keysPressed[e.key] = false;
            
            switch (e.key) {
                case 'ArrowLeft':
                case 'ArrowRight':
                    state.dasCounter = 0;
                    state.arrCounter = 0;
                    break;
            }
        }

        function handleTouchStart(e) {
            if (state.gameOver || state.isPaused) return;
            
            state.touchStartX = e.touches[0].clientX;
            state.touchStartY = e.touches[0].clientY;
            e.preventDefault();
        }

        function handleTouchMove(e) {
            if (state.gameOver || state.isPaused) return;
            
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const diffX = touchX - state.touchStartX;
            const diffY = touchY - state.touchStartY;
            
            if (Math.abs(diffX) > CONFIG.mobileThreshold) {
                if (diffX > 0) {
                    movePiece('right');
                } else {
                    movePiece('left');
                }
                state.touchStartX = touchX;
            }
            
            if (diffY > CONFIG.mobileThreshold) {
                movePiece('down');
                state.touchStartY = touchY;
            }
            
            e.preventDefault();
        }

        function handleTouchEnd(e) {
            if (state.gameOver || state.isPaused) return;
            
            const touchY = e.changedTouches[0].clientY;
            const diffY = state.touchStartY - touchY;
            
            // Swipe up for hard drop
            if (diffY > CONFIG.mobileThreshold) {
                movePiece('up');
            }
            
            // Tap for rotate
            if (Math.abs(diffY) < 10) {
                rotatePiece();
            }
        }

        // ===== GAME LOOP =====
        function gameLoop(timestamp) {
            if (!state.lastFrameTime) {
                state.lastFrameTime = timestamp;
            }
            
            const deltaTime = timestamp - state.lastFrameTime;
            state.lastFrameTime = timestamp;
            
            if (!state.gameOver && !state.isPaused) {
                updateGame(deltaTime);
            }
            
            updateParticles(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function updateGame(deltaTime) {
            // Handle continuous movement (DAS)
            if (state.keysPressed['ArrowLeft'] || state.keysPressed['ArrowRight']) {
                state.dasCounter += deltaTime;
                
                if (state.dasCounter >= CONFIG.dasDelay) {
                    state.arrCounter += deltaTime;
                    
                    while (state.arrCounter >= CONFIG.arrDelay) {
                        if (state.keysPressed['ArrowLeft']) {
                            movePiece('left');
                        } else if (state.keysPressed['ArrowRight']) {
                            movePiece('right');
                        }
                        state.arrCounter -= CONFIG.arrDelay;
                    }
                }
            }
            
            // Handle piece dropping
            state.dropCounter += deltaTime;
            state.lockCounter += deltaTime;
            
            if (state.dropCounter >= state.dropInterval) {
                movePiece('down');
                state.dropCounter = 0;
            }
        }

        // ===== PARTICLE SYSTEM =====
        function createParticle(x, y, size, color, angle, distance) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.backgroundColor = color;
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            particle.style.opacity = Math.random() * 0.5 + 0.5;
            particle.style.boxShadow = `0 0 ${size}px ${color}`;
            
            document.getElementById('gameContainer').appendChild(particle);
            
            state.particles.push({
                element: particle,
                x: x,
                y: y,
                angle: angle * (Math.PI / 180),
                distance: distance,
                startTime: Date.now(),
                duration: Math.random() * 1000 + 500,
                size: size
            });
        }

        function updateParticles(deltaTime) {
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const particle = state.particles[i];
                const elapsed = Date.now() - particle.startTime;
                const progress = elapsed / particle.duration;
                
                if (progress < 1) {
                    // Update position
                    particle.x += Math.cos(particle.angle) * particle.distance * progress / 10;
                    particle.y += Math.sin(particle.angle) * particle.distance * progress / 10;
                    
                    // Update element
                    particle.element.style.left = `${particle.x}px`;
                    particle.element.style.top = `${particle.y}px`;
                    particle.element.style.opacity = 1 - progress;
                    
                    // Scale down
                    particle.element.style.transform = `scale(${1 - progress * 0.5})`;
                } else {
                    // Remove expired particle
                    particle.element.remove();
                    state.particles.splice(i, 1);
                }
            }
        }

        // ===== AUDIO =====
        function playSound(type) {
            // In a real implementation, you would play actual audio files here
            // This is a placeholder for the sound system
            console.log(`Playing sound: ${type}`);
        }

        // ===== INITIALIZE GAME =====
        window.addEventListener('load', () => {
            createGrid();
            createNextPieceGrid();
            createHoldPieceGrid();
            init();
        });
    </script>
</body>
</html>